CREATE FUNCTION java_call_handler()  RETURNS language_handler AS 'pljava' LANGUAGE C;
CREATE FUNCTION javau_call_handler() RETURNS language_handler AS 'pljava' LANGUAGE C;
CREATE TRUSTED LANGUAGE java HANDLER java_call_handler;
CREATE LANGUAGE javaU HANDLER javau_call_handler;
alter database pljava_test owner to pljava_test;
\c pljava_test pljava_test
DROP SCHEMA IF EXISTS javatest CASCADE;
NOTICE:  schema "javatest" does not exist, skipping
CREATE SCHEMA javatest;
set search_path = javatest, public;
set client_min_messages = "info";
CREATE TABLE javatest.test AS
    SELECT 1 as i
    distributed by (i);
CREATE FUNCTION javatest.print(char)
    RETURNS char
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('a'::char);
 print 
-------
 a
(1 row)

SELECT javatest.print('a'::char) FROM javatest.test;
 print 
-------
 a
(1 row)

SELECT * FROM javatest.print('a'::char);
 print 
-------
 a
(1 row)

CREATE FUNCTION javatest.print(varchar)
    RETURNS varchar
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
 
SELECT javatest.print('abc'::varchar);
 print 
-------
 abc
(1 row)

SELECT javatest.print('abc'::varchar) FROM javatest.test;
 print 
-------
 abc
(1 row)

SELECT * FROM javatest.print('abc'::varchar);
 print 
-------
 abc
(1 row)

CREATE FUNCTION javatest.print(bytea)
    RETURNS bytea
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('a'::bytea);
 print 
-------
 a
(1 row)

SELECT javatest.print('a'::bytea) FROM javatest.test;
 print 
-------
 a
(1 row)

SELECT * FROM javatest.print('a'::bytea);
 print 
-------
 a
(1 row)

CREATE FUNCTION javatest.print(int2)
    RETURNS int2
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print(2::int2);
 print 
-------
     2
(1 row)

SELECT javatest.print(2::int2) FROM javatest.test;
 print 
-------
     2
(1 row)

SELECT * FROM javatest.print(2::int2);
 print 
-------
     2
(1 row)

CREATE FUNCTION javatest.print(int2[])
    RETURNS int2[]
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('{2}'::int2[]);
 print 
-------
 {2}
(1 row)

SELECT javatest.print('{2}'::int2[]) FROM javatest.test;
 print 
-------
 {2}
(1 row)

SELECT * FROM javatest.print('{2}'::int2[]);
 print 
-------
 {2}
(1 row)

CREATE FUNCTION javatest.print(int4)
    RETURNS int4
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print(4::int4);
 print 
-------
     4
(1 row)

SELECT javatest.print(4::int4) FROM javatest.test;
 print 
-------
     4
(1 row)

SELECT * FROM javatest.print(4::int4);
 print 
-------
     4
(1 row)

CREATE FUNCTION javatest.print(int4[])
    RETURNS int4[]
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('{4}'::int4[]);
 print 
-------
 {4}
(1 row)

SELECT javatest.print('{4}'::int4[]) FROM javatest.test;
 print 
-------
 {4}
(1 row)

SELECT * FROM javatest.print('{4}'::int4[]);
 print 
-------
 {4}
(1 row)

CREATE FUNCTION javatest.print(int8)
    RETURNS int8
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print(8::int8);
 print 
-------
     8
(1 row)

SELECT javatest.print(8::int8) FROM javatest.test;
 print 
-------
     8
(1 row)

SELECT * FROM javatest.print(8::int8);
 print 
-------
     8
(1 row)

CREATE FUNCTION javatest.print(int8[])
    RETURNS int8[]
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('{8}'::int8[]);
 print 
-------
 {8}
(1 row)

SELECT javatest.print('{8}'::int8[]) FROM javatest.test;
 print 
-------
 {8}
(1 row)

SELECT * FROM javatest.print('{8}'::int8[]);
 print 
-------
 {8}
(1 row)

CREATE FUNCTION javatest.print(real)
    RETURNS real
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print(4.4::real);
 print 
-------
   4.4
(1 row)

SELECT javatest.print(4.4::real) FROM javatest.test;
 print 
-------
   4.4
(1 row)

SELECT * FROM javatest.print(4.4::real);
 print 
-------
   4.4
(1 row)

CREATE FUNCTION javatest.print(real[])
    RETURNS real[]
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('{4.4}'::real[]);
 print 
-------
 {4.4}
(1 row)

SELECT javatest.print('{4.4}'::real[]) FROM javatest.test;
 print 
-------
 {4.4}
(1 row)

SELECT * FROM javatest.print('{4.4}'::real[]);
 print 
-------
 {4.4}
(1 row)

CREATE FUNCTION javatest.print(double precision)
    RETURNS double precision
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print(8.8::double precision);
 print 
-------
   8.8
(1 row)

SELECT javatest.print(8.8::double precision) FROM javatest.test;
 print 
-------
   8.8
(1 row)

SELECT * FROM javatest.print(8.8::double precision);
 print 
-------
   8.8
(1 row)

CREATE FUNCTION javatest.print(double precision[])
    RETURNS double precision[]
    AS 'org.postgresql.pljava.example.Parameters.print'
    LANGUAGE java;
SELECT javatest.print('{8.8}'::double precision[]);
 print 
-------
 {8.8}
(1 row)

SELECT javatest.print('{8.8}'::double precision[]) FROM javatest.test;
 print 
-------
 {8.8}
(1 row)

SELECT * FROM javatest.print('{8.8}'::double precision[]);
 print 
-------
 {8.8}
(1 row)

CREATE FUNCTION javatest.printObj(int[])
    RETURNS int[]
    AS 'org.postgresql.pljava.example.Parameters.print(java.lang.Integer[])'
    LANGUAGE java;
SELECT javatest.printObj('{4}'::int[]);
 printobj 
----------
 {4}
(1 row)

SELECT javatest.printObj('{4}'::int[]) FROM javatest.test;
 printobj 
----------
 {4}
(1 row)

SELECT * FROM javatest.printObj('{4}'::int[]);
 printobj 
----------
 {4}
(1 row)

CREATE FUNCTION javatest.java_addOne(int)
    RETURNS int
    AS 'org.postgresql.pljava.example.Parameters.addOne(java.lang.Integer)'
    IMMUTABLE LANGUAGE java;
SELECT javatest.java_addOne(1);
 java_addone 
-------------
           2
(1 row)

SELECT javatest.java_addOne(1) FROM javatest.test;
 java_addone 
-------------
           2
(1 row)

SELECT * FROM javatest.java_addOne(1);
 java_addone 
-------------
           2
(1 row)

CREATE FUNCTION javatest.nullOnEven(int)
    RETURNS int
    AS 'org.postgresql.pljava.example.Parameters.nullOnEven'
    IMMUTABLE LANGUAGE java;
SELECT javatest.nullOnEven(1);
 nulloneven 
------------
          1
(1 row)

SELECT javatest.nullOnEven(2);
 nulloneven 
------------
           
(1 row)

SELECT javatest.nullOnEven(1) FROM javatest.test;
 nulloneven 
------------
          1
(1 row)

SELECT javatest.nullOnEven(2) FROM javatest.test;
 nulloneven 
------------
           
(1 row)

SELECT * FROM javatest.nullOnEven(1);
 nulloneven 
------------
          1
(1 row)

SELECT * FROM javatest.nullOnEven(2);
 nulloneven 
------------
           
(1 row)

/*
 * This function should fail since file system access is
 * prohibited when the language is trusted.
 */
CREATE FUNCTION javatest.create_temp_file_trusted()
    RETURNS varchar
    AS 'org.postgresql.pljava.example.Security.createTempFile'
    LANGUAGE java;
SELECT javatest.create_temp_file_trusted();
ERROR:  java.lang.SecurityException: Unable to create temporary file (JNICalls.c:76)
SELECT javatest.create_temp_file_trusted() FROM javatest.test;
ERROR:  java.lang.SecurityException: Unable to create temporary file (JNICalls.c:76)  (seg0 slice1 pljava.pivotal.io:40000 pid=28484) (cdbdisp.c:1019)
SELECT * FROM javatest.create_temp_file_trusted();
ERROR:  java.lang.SecurityException: Unable to create temporary file (JNICalls.c:76)
 
CREATE FUNCTION javatest.transferPeople(int)
    RETURNS int
    AS 'org.postgresql.pljava.example.SPIActions.transferPeopleWithSalary'
    LANGUAGE java;
CREATE TABLE javatest.employees1 (
    id        int PRIMARY KEY,
    name      varchar(200),	
    salary    int
) DISTRIBUTED BY (id);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "employees1_pkey" for table "employees1"
CREATE TABLE javatest.employees2 (
    id            int PRIMARY KEY,
    name          varchar(200),
    salary        int,
    transferDay   date,
    transferTime  time
) DISTRIBUTED BY (id);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "employees2_pkey" for table "employees2"
insert into employees1 values (1, 'Adam', 100);
insert into employees1 values (2, 'Brian', 200);
insert into employees1 values (3, 'Caleb', 300);
insert into employees1 values (4, 'David', 400);
SELECT javatest.transferPeople(1);
 transferpeople 
----------------
              4
(1 row)

SELECT * FROM employees1 order by id;
 id | name | salary 
----+------+--------
(0 rows)

SELECT id,name, salary FROM employees2 order by id;
 id | name  | salary 
----+-------+--------
  1 | Adam  |    100
  2 | Brian |    200
  3 | Caleb |    300
  4 | David |    400
(4 rows)

SELECT javatest.transferPeople(1) FROM javatest.test;  -- should error
ERROR:  function cannot execute on segment because it accesses relation "javatest.employees1" (functions.c:155)  (seg0 slice1 pljava.pivotal.io:40000 pid=28484) (cdbdisp.c:1019)
DETAIL:  SQL statement "SELECT id, name, salary FROM employees1 WHERE salary > $1"
